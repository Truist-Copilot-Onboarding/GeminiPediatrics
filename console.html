<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WS Server Console</title>
  <style>
    :root { 
      color-scheme: light dark; 
      --primary: #1e90ff;
      --success: #28a745;
      --error: #dc3545;
      --bg: #f8f9fa;
      --card-bg: #fff;
      --text: #333;
      --muted: #6c757d;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #222;
        --card-bg: #333;
        --text: #fff;
        --muted: #aaa;
      }
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 1rem;
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 1rem;
      color: var(--primary);
    }
    .muted { color: var(--muted); }
    .card {
      background: var(--card-bg);
      border: 1px solid #ccc3;
      border-radius: 10px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .row {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .row label {
      width: 100px;
      font-weight: 500;
    }
    .row > div { flex: 1; }
    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    input, select, button {
      font: inherit;
      padding: 0.5rem 1rem;
      border: 1px solid #ccc;
      border-radius: 5px;
      background: #fff;
      color: #000; /* High contrast */
    }
    @media (prefers-color-scheme: dark) {
      input, select, button {
        background: #444;
        color: #fff; /* High contrast */
      }
    }
    select {
      width: 200px;
    }
    button {
      background: var(--primary);
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover:not(:disabled) {
      background: #1c86ee;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .kill-btn {
      background: var(--error);
    }
    .kill-btn:hover:not(:disabled) {
      background: #c82333;
    }
    .blacklist-btn {
      background: #ff9500;
    }
    .blacklist-btn:hover:not(:disabled) {
      background: #e68a00;
    }
    pre {
      background: #1a1a1a;
      color: #0f0;
      padding: 1rem;
      border-radius: 5px;
      max-height: 80vh;
      overflow: auto;
      font-family: ui-monospace, monospace;
      font-size: 0.9rem;
    }
    .log-controls {
      position: sticky;
      top: 0;
      background: var(--card-bg);
      padding: 0.5rem 0;
      z-index: 10;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    #searchLogs {
      max-width: 150px; /* Shortened search bar */
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.5rem;
      text-align: left;
    }
    th {
      background: var(--card-bg);
    }
    a { color: var(--primary); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>WebSocket Server Console</h1>
  <p class="muted">
    Live server logs streamed from <code>/logs</code> (SSE). Return to <a href="/">tester</a>.
  </p>
  <div class="card">
    <div class="row">
      <label>Connected Clients</label>
      <div>
        <table id="clientTable">
          <thead>
            <tr>
              <th>IP</th>
              <th>Client ID</th>
              <th>Connected At</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="clientList"></tbody>
        </table>
      </div>
    </div>
    <div class="row">
      <label>Blacklisted IPs</label>
      <div>
        <table id="blacklistTable">
          <thead>
            <tr>
              <th>IP</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="blacklist"></tbody>
        </table>
      </div>
    </div>
    <div class="row">
      <label>Server Logs</label>
      <div>
        <div class="log-controls">
          <button id="copyLogs">Copy Logs</button>
          <button id="downloadLogs">Download Logs</button>
          <button id="pauseLogs">Pause Logs</button>
          <input id="searchLogs" placeholder="Search logs..."/>
          <select id="logFilter">
            <option value="all">All Logs</option>
            <option value="ping">Ping</option>
            <option value="pong">Pong</option>
            <option value="file-transfers">File Transfers</option>
            <option value="errors">Errors</option>
            <option value="connections">Connection Events</option>
            <option value="messages">Messages</option>
          </select>
        </div>
        <pre id="log"></pre>
      </div>
    </div>
  </div>
  <script>
    (function() {
      const logEl = document.getElementById('log');
      const copyLogsBtn = document.getElementById('copyLogs');
      const downloadLogsBtn = document.getElementById('downloadLogs');
      const pauseLogsBtn = document.getElementById('pauseLogs');
      const searchLogs = document.getElementById('searchLogs');
      const logFilter = document.getElementById('logFilter');
      const clientList = document.getElementById('clientList');
      const blacklist = document.getElementById('blacklist');
      let logLines = [], isPaused = false;
      const MAX_LOG_LINES = 5000; // Increased for longer history
      const debounce = (fn, delay) => {
        let timeout;
        return (...args) => {
          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(() => {
            fn(...args);
            timeout = null;
          }, delay);
        };
      };
      const log = (m) => {
        const s = new Date().toISOString() + ' [CONSOLE] ' + m;
        console.log(s);
        logLines.push(s);
        if (logLines.length > MAX_LOG_LINES) logLines.shift();
        updateLogDisplay();
      };
      const updateLogDisplay = debounce(() => {
        if (isPaused) return;
        const searchTerm = searchLogs.value.toLowerCase();
        const selectedFilter = logFilter.value;
        const filteredLogs = logLines.filter(line => {
          const isPing = line.includes('PING') || line.includes('heartbeat');
          const isPong = line.includes('PONG');
          const isFileTransfer = line.includes('FILE CHUNK') || line.includes('FILE META') || line.includes('FILE END') || 
                                line.includes('UPLOAD COMPLETE') || line.includes('DELETE COMPLETE') || line.includes('Unzip file error') || line.includes('FILE LIST');
          const isError = line.includes('ERROR') || line.includes('failed') || line.includes('mismatch');
          const isConnection = line.includes('OPEN') || line.includes('CLOSE') || line.includes('ERROR') || line.includes('WELCOME');
          const isMessage = line.includes('SAY') || line.includes('MSG');
          if (selectedFilter === 'all') return searchTerm ? line.toLowerCase().includes(searchTerm) : true;
          if (selectedFilter === 'ping') return isPing && (searchTerm ? line.toLowerCase().includes(searchTerm) : true);
          if (selectedFilter === 'pong') return isPong && (searchTerm ? line.toLowerCase().includes(searchTerm) : true);
          if (selectedFilter === 'file-transfers') return isFileTransfer && (searchTerm ? line.toLowerCase().includes(searchTerm) : true);
          if (selectedFilter === 'errors') return isError && (searchTerm ? line.toLowerCase().includes(searchTerm) : true);
          if (selectedFilter === 'connections') return isConnection && (searchTerm ? line.toLowerCase().includes(searchTerm) : true);
          if (selectedFilter === 'messages') return isMessage && (searchTerm ? line.toLowerCase().includes(searchTerm) : true);
          return true;
        });
        logEl.textContent = filteredLogs.join('\n');
        logEl.scrollTop = logEl.scrollHeight;
      }, 100);
      copyLogsBtn.onclick = async () => {
        try { 
          await navigator.clipboard.writeText(logEl.textContent); 
          log('Logs copied to clipboard'); 
        } catch (e) {
          log('Copy failed: ' + e.message);
          const t = document.createElement('textarea'); 
          t.value = logEl.textContent; 
          document.body.appendChild(t); 
          t.select(); 
          document.execCommand('copy'); 
          t.remove();
          log('Logs copied using fallback');
        }
      };
      downloadLogsBtn.onclick = () => {
        try {
          const blob = new Blob([logLines.join('\n')], { type: 'text/plain' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `console_logs_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 120000);
          log('Logs downloaded as file');
        } catch (e) {
          log('Download logs failed: ' + e.message);
        }
      };
      pauseLogsBtn.onclick = () => {
        isPaused = !isPaused;
        pauseLogsBtn.textContent = isPaused ? 'Resume Logs' : 'Pause Logs';
        if (!isPaused) updateLogDisplay();
        log(isPaused ? 'Logs paused' : 'Logs resumed');
      };
      searchLogs.oninput = () => {
        log('Search logs: ' + searchLogs.value);
        updateLogDisplay();
      };
      logFilter.onchange = () => {
        log('Log filter changed to: ' + logFilter.value);
        updateLogDisplay();
      };
      async function fetchClients() {
        try {
          const res = await fetch('/console/clients', {
            headers: { 'Authorization': 'Basic ' + btoa('womprats:womprats') }
          });
          if (!res.ok) throw new Error('Failed to fetch clients: ' + res.status);
          const clients = await res.json();
          clientList.innerHTML = '';
          clients.forEach(client => {
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${client.ip}</td>
              <td>${client.clientId}</td>
              <td>${new Date(client.connectedAt).toISOString()}</td>
              <td>
                <button class="kill-btn" data-client-id="${client.clientId}">Kill</button>
                <button class="blacklist-btn" data-ip="${client.ip}">Blacklist</button>
              </td>
            `;
            clientList.appendChild(row);
          });
          clientList.querySelectorAll('.kill-btn').forEach(btn => {
            btn.onclick = async () => {
              try {
                const res = await fetch('/console/kill', {
                  method: 'POST',
                  headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': 'Basic ' + btoa('womprats:womprats')
                  },
                  body: JSON.stringify({ clientId: btn.dataset.clientId })
                });
                if (!res.ok) throw new Error('Failed to kill client: ' + res.status);
                log(`Killed client ${btn.dataset.clientId}`);
                fetchClients();
              } catch (e) {
                log('Kill client failed: ' + e.message);
              }
            };
          });
          clientList.querySelectorAll('.blacklist-btn').forEach(btn => {
            btn.onclick = async () => {
              try {
                const res = await fetch('/console/blacklist', {
                  method: 'POST',
                  headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': 'Basic ' + btoa('womprats:womprats')
                  },
                  body: JSON.stringify({ ip: btn.dataset.ip })
                });
                if (!res.ok) throw new Error('Failed to blacklist IP: ' + res.status);
                log(`Blacklisted IP ${btn.dataset.ip}`);
                fetchClients();
                fetchBlacklist();
              } catch (e) {
                log('Blacklist IP failed: ' + e.message);
              }
            };
          });
        } catch (e) {
          log('Fetch clients error: ' + e.message);
        }
      }
      async function fetchBlacklist() {
        try {
          const res = await fetch('/console/blacklist', {
            headers: { 'Authorization': 'Basic ' + btoa('womprats:womprats') }
          });
          if (!res.ok) throw new Error('Failed to fetch blacklist: ' + res.status);
          const ips = await res.json();
          blacklist.innerHTML = '';
          ips.forEach(ip => {
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${ip}</td>
              <td>
                <button class="blacklist-btn" data-ip="${ip}">Unblacklist</button>
              </td>
            `;
            blacklist.appendChild(row);
          });
          blacklist.querySelectorAll('.blacklist-btn').forEach(btn => {
            btn.onclick = async () => {
              try {
                const res = await fetch('/console/unblacklist', {
                  method: 'POST',
                  headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': 'Basic ' + btoa('womprats:womprats')
                  },
                  body: JSON.stringify({ ip: btn.dataset.ip })
                });
                if (!res.ok) throw new Error('Failed to unblacklist IP: ' + res.status);
                log(`Unblacklisted IP ${btn.dataset.ip}`);
                fetchBlacklist();
              } catch (e) {
                log('Unblacklist IP failed: ' + e.message);
              }
            };
          });
        } catch (e) {
          log('Fetch blacklist error: ' + e.message);
        }
      }
      const es = new EventSource('/logs');
      es.onopen = () => log('SSE connection opened');
      es.onmessage = (e) => { 
        logLines.push(e.data); 
        if (logLines.length > MAX_LOG_LINES) logLines.shift();
        updateLogDisplay();
      };
      es.onerror = () => { 
        log('SSE connection error or closed');
        updateLogDisplay();
      };
      fetchClients();
      fetchBlacklist();
      setInterval(() => {
        fetchClients();
        fetchBlacklist();
      }, 5000); // Refresh every 5 seconds
    })();
  </script>
</body>
</html>
