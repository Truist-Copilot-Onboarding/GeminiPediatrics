<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WS Tunnel (Heroku)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root { 
      color-scheme: light dark; 
      --primary: #1e90ff;
      --success: #28a745;
      --error: #dc3545;
      --bg: #f8f9fa;
      --card-bg: #fff;
      --text: #333;
      --muted: #6c757d;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #222;
        --card-bg: #333;
        --text: #ddd;
        --muted: #aaa;
      }
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 1rem;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      display: flex;
      gap: 1rem;
      min-height: 100vh;
    }
    .left-column {
      flex: 0 0 300px;
    }
    .right-column {
      flex: 1;
      min-width: 300px;
    }
    @media (max-width: 800px) {
      body {
        flex-direction: column;
      }
      .left-column, .right-column {
        flex: 1;
      }
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 1rem;
      color: var(--primary);
    }
    .muted { color: var(--muted); }
    .card {
      background: var(--card-bg);
      border: 1px solid #ccc3;
      border-radius: 10px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .row {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .row label {
      width: 100px;
      font-weight: 500;
    }
    .row > div { flex: 1; }
    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    input, select, button {
      font: inherit;
      padding: 0.5rem 1rem;
      border: 1px solid #ccc;
      border-radius: 5px;
      background: #fff;
      color: var(--text);
    }
    button {
      background: var(--primary);
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover:not(:disabled) {
      background: #1c86ee;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .delete-btn {
      background: var(--error);
    }
    .delete-btn:hover:not(:disabled) {
      background: #c82333;
    }
    .ok { color: var(--success); }
    .bad { color: var(--error); }
    pre {
      background: #1a1a1a;
      color: #0f0;
      padding: 1rem;
      border-radius: 5px;
      max-height: 80vh;
      overflow: auto;
      font-family: ui-monospace, monospace;
      font-size: 0.9rem;
    }
    .log-controls {
      position: sticky;
      top: 0;
      background: var(--card-bg);
      padding: 0.5rem 0;
      z-index: 10;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    progress {
      width: 100%;
      height: 1.2rem;
      border-radius: 5px;
    }
    a { color: var(--primary); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="left-column">
    <h1>WebSocket Tunnel (Heroku)</h1>
    <p class="muted">
      Connects to <code>/ws-tunnel</code>. Echo at <code>/ws-echo</code>. Live logs at <a href="/console" target="_blank">/console</a>.<br>
      File download: <a href="/files/HelloWorld.zip" target="_blank">/files/HelloWorld.zip</a> (example).
    </p>
    <div class="card">
      <div class="row">
        <label>Endpoint</label>
        <div><code id="ep"></code></div>
      </div>
      <div class="row">
        <label>Status</label>
        <div id="status">Connecting...</div>
      </div>
      <div class="row">
        <label>RTT (avg)</label>
        <div id="rtt">--</div>
      </div>
    </div>
    <div class="card">
      <div class="row">
        <label>Send Message</label>
        <div class="controls">
          <input id="msg" placeholder="Type text (or 'ping')" style="flex: 1"/>
          <button id="send" disabled>Send</button>
          <button id="reconnect">Reconnect</button>
        </div>
      </div>
      <div class="row">
        <label>File Operations</label>
        <div class="controls">
          <select id="fileSelect" disabled>
            <option value="">Select a file...</option>
          </select>
          <button id="downloadBtn" disabled>Download</button>
          <button id="deleteBtn" disabled class="delete-btn">Delete</button>
        </div>
      </div>
      <div class="row">
        <label>Upload File</label>
        <div class="controls">
          <input type="file" id="fileInput" disabled/>
          <button id="uploadBtn" disabled>Upload</button>
        </div>
      </div>
      <div class="row">
        <label>Transfer Progress</label>
        <div>
          <div id="transferInfo" class="muted">Waiting...</div>
          <progress id="transferProg" max="100" value="0"></progress>
        </div>
      </div>
    </div>
  </div>
  <div class="right-column">
    <div class="card">
      <div class="row">
        <label>Client Logs</label>
        <div>
          <div class="log-controls">
            <button id="copyLogs">Copy Logs</button>
            <button id="pauseLogs">Pause Logs</button>
            <input id="searchLogs" placeholder="Search logs..." style="flex: 1"/>
            <label><input type="checkbox" id="filterPingPong" checked> Filter Ping/Pong</label>
          </div>
          <pre id="log"></pre>
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      const url = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws-tunnel';
      document.getElementById('ep').textContent = url;
      const status = document.getElementById('status');
      const logEl = document.getElementById('log');
      const rttEl = document.getElementById('rtt');
      const sendBtn = document.getElementById('send');
      const reconnectBtn = document.getElementById('reconnect');
      const copyLogsBtn = document.getElementById('copyLogs');
      const pauseLogsBtn = document.getElementById('pauseLogs');
      const searchLogs = document.getElementById('searchLogs');
      const filterPingPong = document.getElementById('filterPingPong');
      const fileSelect = document.getElementById('fileSelect');
      const downloadBtn = document.getElementById('downloadBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');
      const transferInfo = document.getElementById('transferInfo');
      const transferProg = document.getElementById('transferProg');
      const MAX_LOG_LINES = 100;
      let logLines = [], isPaused = false;
      const debounce = (fn, delay) => {
        let timeout;
        return (...args) => {
          if (timeout) return;
          timeout = setTimeout(() => {
            fn(...args);
            timeout = null;
          }, delay);
        };
      };
      const disableDuringTransfer = (fn) => {
        return (...args) => {
          if (rx || tx) {
            log('Action blocked: transfer in progress');
            return;
          }
          fn(...args);
        };
      };
      const log = (m) => { 
        if (filterPingPong.checked && (m.includes('PING') || m.includes('PONG') || m.includes('serverPing'))) return;
        const s = new Date().toISOString() + ' ' + m; 
        console.log(s); 
        logLines.push(s);
        if (logLines.length > MAX_LOG_LINES) logLines.shift();
        updateLogDisplay();
      };
      const updateLogDisplay = () => {
        if (isPaused) return;
        const searchTerm = searchLogs.value.toLowerCase();
        const filteredLogs = searchTerm ? logLines.filter(line => line.toLowerCase().includes(searchTerm)) : logLines;
        logEl.textContent = filteredLogs.join('\n');
        logEl.scrollTop = logEl.scrollHeight;
      };
      const setSend = (on) => {
        sendBtn.disabled = !on;
        downloadBtn.disabled = !on || (rx || tx);
        fileSelect.disabled = !on;
        deleteBtn.disabled = !on || (rx || tx);
        fileInput.disabled = !on || (rx || tx);
        uploadBtn.disabled = !on || (rx || tx);
      };
      const mean = (a) => a.length ? a.reduce((x, y) => x + y, 0) / a.length : 0;
      copyLogsBtn.onclick = debounce(async () => {
        try { 
          await navigator.clipboard.writeText(logEl.textContent); 
          log('Logs copied to clipboard'); 
        } catch (e) {
          log('Copy failed: ' + e.message);
          const t = document.createElement('textarea'); 
          t.value = logEl.textContent; 
          document.body.appendChild(t); 
          t.select(); 
          document.execCommand('copy'); 
          t.remove();
          log('Logs copied using fallback');
        }
      }, 500);
      pauseLogsBtn.onclick = debounce(() => {
        isPaused = !isPaused;
        pauseLogsBtn.textContent = isPaused ? 'Resume Logs' : 'Pause Logs';
        if (!isPaused) updateLogDisplay();
        log(isPaused ? 'Logs paused' : 'Logs resumed');
      }, 500);
      searchLogs.oninput = debounce(() => {
        log('Search logs: ' + searchLogs.value);
        updateLogDisplay();
      }, 300);
      let ws, sent = new Map(), rtts = [], reconnectAttempts = 0;
      let rx = null, tx = null;
      function resetTransfer() { 
        rx = null; 
        tx = null;
        transferInfo.textContent = 'Waiting...'; 
        transferProg.value = 0; 
        transferProg.max = 100;
        setSend(ws && ws.readyState === ws.OPEN);
      }
      async function fetchFiles() {
        try {
          const res = await fetch('/files');
          if (!res.ok) throw new Error('Failed to fetch files: ' + res.status);
          const files = await res.json();
          fileSelect.innerHTML = '<option value="">Select a file...</option>';
          files.forEach(file => {
            if (file.size > 0) {
              const opt = document.createElement('option');
              opt.value = file.name;
              opt.textContent = `${file.name} (${file.size > 1024 * 1024 ? (file.size / 1024 / 1024).toFixed(1) + ' MB' : (file.size / 1024).toFixed(1) + ' KB'})`;
              fileSelect.appendChild(opt);
            }
          });
          log('Fetched file list: ' + files.map(f => f.name).join(', '));
        } catch (e) {
          log('Fetch files error: ' + e.message);
          fileSelect.innerHTML = '<option value="">No files available</option>';
        }
      }
      function cleanupSentMap() {
        const now = performance.now();
        for (const [id, t0] of sent) {
          if (now - t0 > 5000) {
            log(`PING timeout id=${id}`);
            sent.delete(id);
          }
        }
      }
      function b64ToBytes(b64) {
        try {
          const bin = atob(b64);
          const len = bin.length;
          const out = new Uint8Array(len);
          for (let i = 0; i < len; i++) out[i] = bin.charCodeAt(i) & 0xFF;
          return out;
        } catch (e) {
          log('b64ToBytes error: ' + e.message);
          return new Uint8Array(0);
        }
      }
      async function zipFile(file) {
        try {
          const zip = new JSZip();
          zip.file(file.name, file);
          const blob = await zip.generateAsync({ type: 'arraybuffer', compression: 'STORE' });
          return new Uint8Array(blob);
        } catch (e) {
          log('Zip file error: ' + e.message);
          throw e;
        }
      }
      async function unzipFile(bytes, originalName) {
        try {
          const zip = new JSZip();
          const unzipped = await zip.loadAsync(bytes);
          const file = unzipped.file(originalName);
          if (!file) throw new Error('File not found in zip: ' + originalName);
          const blob = await file.async('blob');
          return new Blob([blob], { type: 'application/octet-stream' });
        } catch (e) {
          log('Unzip file error: ' + e.message);
          throw e;
        }
      }
      function connect() {
        log('Attempting connection to ' + url + ' (attempt ' + (reconnectAttempts + 1) + ')');
        try {
          ws = new WebSocket(url, ['tunnel'], { perMessageDeflate: false, headers: { 'Sec-WebSocket-Extensions': 'none' } });
          log('WebSocket created: ' + url);
        } catch (e) {
          log('WebSocket creation failed: ' + e.message);
          status.innerHTML = '<span class="bad">ERROR</span> - Check logs or network';
          setTimeout(connect, 5000);
          return;
        }
        ws.onopen = () => { 
          status.innerHTML = '<span class="ok">OPEN</span>'; 
          log('OPEN ' + url); 
          setSend(true); 
          reconnectAttempts = 0;
          fetchFiles();
          try {
            const id1 = Math.random().toString(36).slice(2);
            sent.set(id1, performance.now());
            ws.send(JSON.stringify({ type: 'ping', id: id1, clientTs: Date.now() }));
            log('Client sent initial ping id=' + id1);
            setTimeout(() => {
              if (ws.readyState === ws.OPEN) {
                const id2 = Math.random().toString(36).slice(2);
                sent.set(id2, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id: id2, clientTs: Date.now() }));
                log('Client sent second ping id=' + id2);
              }
            }, 50);
          } catch (e) { 
            log('Client send error: ' + e.message); 
          }
          const heartbeat = setInterval(() => {
            if (ws.readyState === ws.OPEN) {
              try {
                const id = Math.random().toString(36).slice(2);
                sent.set(id, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() }));
                log('Client heartbeat ping id=' + id);
                cleanupSentMap();
              } catch (e) {
                log('Client heartbeat error: ' + e.message);
              }
            } else {
              clearInterval(heartbeat);
            }
          }, 500);
        };
        ws.onerror = (e) => { 
          log('WebSocket error: ' + (e.message || 'Unknown error')); 
          status.innerHTML = '<span class="bad">ERROR</span> - Check logs or try direct download';
          setSend(false);
        };
        ws.onclose = (e) => {
          status.innerHTML = '<span class="bad">CLOSED</span> code=' + e.code; 
          setSend(false); 
          log('CLOSE code=' + e.code + ' reason="' + e.reason + '"');
          reconnectAttempts++;
          const delay = Math.min(20000, 5000 + reconnectAttempts * 3000);
          log('Reconnecting in ' + delay + 'ms');
          setTimeout(connect, delay);
        };
        ws.onmessage = async (ev) => {
          const start = performance.now();
          let m = null;
          try { 
            m = JSON.parse(ev.data); 
            log('MESSAGE received text length=' + ev.data.length + ' content=' + ev.data.slice(0, 200));
          } catch { 
            return log('TEXT parse error: ' + String(ev.data).slice(0, 200)); 
          }
          if (m.type === 'welcome') { 
            log('WELCOME id=' + m.clientId + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m.type === 'serverPing') { 
            log('serverPing ' + m.serverTs); 
            return; 
          }
          if (m.type === 'readyForUpload') {
            log('READY for upload id=' + m.id);
            if (tx && tx.id === m.id) {
              tx.ready = true;
            }
            return;
          }
          if (m.type === 'error') { 
            log('ERROR ' + m.message); 
            transferInfo.textContent = 'Error: ' + m.message;
            resetTransfer();
            return; 
          }
          if (m.type === 'pong') {
            const t0 = sent.get(m.id);
            if (t0) { 
              const dt = performance.now() - t0; 
              if (dt <= 5000) {
                rtts.push(dt); 
                if (rtts.length > 20) rtts.shift(); 
                rttEl.textContent = mean(rtts).toFixed(1) + 'ms'; 
              } else {
                log(`PONG ignored (RTT=${dt.toFixed(1)}ms too high) id=${m.id}`);
              }
              sent.delete(m.id); 
            }
            log('PONG id=' + m.id + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m.type === 'fileMeta') {
            resetTransfer();
            rx = {
              id: m.id,
              name: m.name || 'download.zip',
              originalName: m.originalName || m.name || 'download.bin',
              size: Number(m.size) || 0,
              mime: 'application/zip',
              totalChunks: Number(m.chunks) || 0,
              chunkSize: Number(m.chunkSize) || 0,
              offset: 0,
              gotChunks: 0,
              buf: new Uint8Array(Number(m.size) || 0),
              hash: m.hash
            };
            transferInfo.textContent = `Receiving ${rx.name} (${rx.size} bytes, ${rx.mime}) in ${rx.totalChunks} chunks...`;
            transferProg.max = rx.size || 1;
            log('FILE META ' + JSON.stringify(m));
            try {
              ws.send(JSON.stringify({ type: 'ready', id: m.id, clientTs: Date.now() }));
              log('Client sent ready id=' + m.id);
            } catch (e) { 
              log('Client ready error: ' + e.message); 
            }
            return;
          }
          if (m.type === 'fileChunk' && rx && m.id === rx.id) {
            try {
              const bytes = b64ToBytes(m.data || '');
              if (bytes.length === 0) {
                log('FILE CHUNK empty or invalid id=' + m.id + ' seq=' + m.seq);
                return;
              }
              if (m.seq !== rx.gotChunks) {
                log(`FILE CHUNK out of order id=${m.id} expected seq=${rx.gotChunks}, got=${m.seq}`);
                return;
              }
              const chunkHash = new Uint8Array(await crypto.subtle.digest('SHA-256', bytes)).reduce((s, b) => s + b.toString(16).padStart(2, '0'), '');
              if (chunkHash !== m.hash) {
                log(`FILE CHUNK hash mismatch id=${m.id} seq=${m.seq} expected=${m.hash}, got=${chunkHash}`);
                return;
              }
              rx.buf.set(bytes, rx.offset);
              rx.offset += bytes.length;
              rx.gotChunks++;
              transferProg.value = rx.offset;
              if ((rx.gotChunks % 16) === 0 || rx.gotChunks === rx.totalChunks) {
                log(`FILE CHUNK ${rx.gotChunks}/${rx.totalChunks} (+${bytes.length}B) id=${m.id}`);
              }
            } catch (e) {
              log('FILE CHUNK error: ' + e.message);
              transferInfo.textContent = 'Download failed: ' + e.message;
            }
            return;
          }
          if (m.type === 'fileEnd' && rx && m.id === rx.id) {
            log('FILE END ok=' + (!!m.ok) + ' total=' + rx.offset + ' bytes id=' + m.id);
            try {
              if (rx.offset !== rx.size) {
                throw new Error(`Size mismatch: expected ${rx.size}, got ${rx.offset}`);
              }
              const finalHash = new Uint8Array(await crypto.subtle.digest('SHA-256', rx.buf)).reduce((s, b) => s + b.toString(16).padStart(2, '0'), '');
              if (finalHash !== rx.hash) {
                throw new Error(`Final hash mismatch: expected ${rx.hash}, got ${finalHash}`);
              }
              const blob = await unzipFile(rx.buf, rx.originalName);
              log(`Unzipped file ${rx.originalName} size=${blob.size}`);
              const a = document.createElement('a');
              a.href = URL.createObjectURL(blob);
              a.download = rx.originalName;
              document.body.appendChild(a);
              a.click();
              setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 120000);
              transferInfo.textContent = 'Downloaded: ' + rx.originalName + ' (' + rx.offset + ' bytes)';
              fetchFiles();
            } catch (e) {
              log('DOWNLOAD trigger failed: ' + e.message);
              transferInfo.textContent = 'Download failed: ' + e.message + '. Try <a href="/files/' + rx.name + '">direct download</a>.';
            }
            resetTransfer();
            return;
          }
          if (m.type === 'uploadComplete') {
            log('UPLOAD COMPLETE id=' + m.id + ' file=' + m.fileName + ' size=' + m.size);
            transferInfo.textContent = 'Uploaded: ' + m.fileName + ' (' + m.size + ' bytes)';
            resetTransfer();
            fetchFiles();
            return;
          }
          if (m.type === 'deleteComplete') {
            log('DELETE COMPLETE id=' + m.id + ' file=' + m.fileName);
            transferInfo.textContent = 'Deleted: ' + m.fileName;
            resetTransfer();
            fetchFiles();
            return;
          }
          if (m.type === 'say') { 
            log('SAY ' + JSON.stringify(m)); 
            return; 
          }
          log('MSG ' + JSON.stringify(m));
        };
      }
      downloadBtn.onclick = debounce(disableDuringTransfer(() => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('DOWNLOAD blocked (socket not open)'); 
          return; 
        }
        const fileName = fileSelect.value;
        if (!fileName) {
          log('DOWNLOAD blocked (no file selected)');
          return;
        }
        try {
          const id = Math.random().toString(36).slice(2);
          ws.send(JSON.stringify({ type: 'requestFile', id, fileName, clientTs: Date.now() }));
          log('Client requested file id=' + id + ' file=' + fileName);
        } catch (e) {
          log('Download request error: ' + e.message);
        }
      }), 500);
      deleteBtn.onclick = debounce(disableDuringTransfer(() => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('DELETE blocked (socket not open)'); 
          return; 
        }
        const fileName = fileSelect.value;
        if (!fileName) {
          log('DELETE blocked (no file selected)');
          return;
        }
        if (!confirm(`Are you sure you want to delete ${fileName}?`)) {
          log('DELETE cancelled by user');
          return;
        }
        try {
          const id = Math.random().toString(36).slice(2);
          ws.send(JSON.stringify({ type: 'deleteFile', id, fileName, clientTs: Date.now() }));
          log('Client requested delete id=' + id + ' file=' + fileName);
        } catch (e) {
          log('Delete request error: ' + e.message);
        }
      }), 500);
      uploadBtn.onclick = debounce(disableDuringTransfer(async () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('UPLOAD blocked (socket not open)'); 
          return; 
        }
        const file = fileInput.files[0];
        if (!file) {
          log('UPLOAD blocked (no file selected)');
          return;
        }
        if (file.size > 10 * 1024 * 1024) {
          log('UPLOAD blocked: file too large (max 10MB)');
          transferInfo.textContent = 'Upload failed: file too large (max 10MB)';
          return;
        }
        try {
          const id = Math.random().toString(36).slice(2);
          const chunkSize = 64 * 1024;
          const zipBytes = await zipFile(file);
          const totalChunks = Math.ceil(zipBytes.length / chunkSize);
          tx = { id, fileName: file.name + '.zip', originalName: file.name, size: zipBytes.length, totalChunks, chunkSize, sentChunks: 0, ready: false, zipBytes };
          transferInfo.textContent = `Uploading ${tx.fileName} (${tx.size} bytes, application/zip) in ${tx.totalChunks} chunks...`;
          transferProg.max = tx.size || 1;
          log(`Starting upload for ${tx.fileName} size=${tx.size} chunks=${tx.totalChunks}`);
          ws.send(JSON.stringify({ type: 'uploadFileMeta', id, fileName: tx.fileName, originalName: tx.originalName, totalChunks, size: tx.size, mime: 'application/zip', clientTs: Date.now() }));
          const sendChunk = async (i) => {
            if (i >= totalChunks || !tx || !tx.ready) return;
            const start = i * chunkSize;
            const end = Math.min(tx.size, start + chunkSize);
            const bytes = tx.zipBytes.subarray(start, end);
            if (bytes.length === 0) {
              log(`UPLOAD chunk ${i + 1} failed: empty data`);
              transferInfo.textContent = 'Upload failed: empty chunk data';
              resetTransfer();
              return;
            }
            const b64 = btoa(String.fromCharCode.apply(null, bytes));
            const chunkHash = new Uint8Array(await crypto.subtle.digest('SHA-256', bytes)).reduce((s, b) => s + b.toString(16).padStart(2, '0'), '');
            try {
              ws.send(JSON.stringify({ type: 'uploadFile', id, seq: i, data: b64, hash: chunkHash, clientTs: Date.now() }));
              tx.sentChunks++;
              transferProg.value = end;
              log(`UPLOAD chunk ${tx.sentChunks}/${tx.totalChunks} (+${bytes.length}B) id=${id}`);
              setTimeout(() => sendChunk(i + 1), 100);
            } catch (e) {
              log('UPLOAD chunk error: ' + e.message);
              transferInfo.textContent = 'Upload failed: ' + e.message;
              resetTransfer();
            }
          };
          const waitForReady = setInterval(() => {
            if (tx && tx.ready) {
              clearInterval(waitForReady);
              sendChunk(0);
            }
          }, 100);
        } catch (e) {
          log('Upload preparation error: ' + e.message);
          transferInfo.textContent = 'Upload failed: ' + e.message;
          resetTransfer();
        }
      }), 500);
      sendBtn.onclick = debounce(() => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('SEND blocked (socket not open)'); 
          return; 
        }
        const text = (msg.value || 'ping').trim();
        if (text.toLowerCase() === 'ping') {
          const id = Math.random().toString(36).slice(2);
          sent.set(id, performance.now());
          try { 
            ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() })); 
            log('PING id=' + id); 
          } catch (e) { 
            log('Send ping error: ' + e.message); 
          }
        } else {
          try { 
            ws.send(JSON.stringify({ type: 'say', text, clientTs: Date.now() })); 
            log('SEND text=' + text); 
          } catch (e) { 
            log('Send text error: ' + e.message); 
          }
        }
        msg.value = '';
      }, 500);
      reconnectBtn.onclick = debounce(() => { 
        try { if (ws) ws.close(); } catch {} 
        connect(); 
      }, 500);
      connect();
    })();
  </script>
</body>
</html>
