<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WS Tunnel (Heroku)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui; padding: 2rem; max-width: 960px; margin: auto; }
    .row { display: grid; grid-template-columns: 140px 1fr; gap: 0.5rem 1rem; align-items: center; }
    .card { border: 1px solid #ccc3; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .ok { color: #0b7; } .bad { color: #b22; } .muted { opacity: 0.8; }
    pre { background: #111; color: #0f0; padding: 12px; border-radius: 8px; white-space: pre-wrap; max-height: 260px; overflow: auto; }
    input, button, select { font: inherit; padding: 0.45rem; }
    button:disabled { opacity: 0.5; }
    a { color: inherit; }
    progress { width: 100%; }
  </style>
</head>
<body>
  <h1>WebSocket Tunnel (Heroku)</h1>
  <p class="muted">
    Connects to <code>/ws-tunnel</code>. Echo at <code>/ws-echo</code>. Live logs at <a href="/console" target="_blank">/console</a>.<br>
    File download: <a href="/files/HelloWorld.zip" target="_blank">/files/HelloWorld.zip</a> (example).
  </p>
  <div class="row"><div>Endpoint</div><div><code id="ep"></code></div></div>
  <div class="row"><div>Status</div><div id="status">Connecting...</div></div>
  <div class="row"><div>RTT (avg)</div><div id="rtt">--</div></div>
  <div class="card">
    <div class="row"><div>Send</div>
      <div>
        <input id="msg" placeholder="Type text (or 'ping')"/>
        <button id="send" disabled>Send</button>
        <button id="reconnect">Reconnect</button>
      </div>
    </div>
    <div class="row"><div>Download File</div>
      <div>
        <select id="fileSelect" disabled>
          <option value="">Select a file...</option>
        </select>
        <button id="downloadBtn" disabled>Download</button>
        <button id="deleteBtn" disabled>Delete</button>
      </div>
    </div>
    <div class="row"><div>Upload File</div>
      <div>
        <input type="file" id="fileInput" disabled/>
        <button id="uploadBtn" disabled>Upload</button>
      </div>
    </div>
    <div class="row"><div>Transfer Progress</div>
      <div>
        <div id="transferInfo" class="muted">Waiting...</div>
        <progress id="transferProg" max="100" value="0"></progress>
      </div>
    </div>
  </div>
  <div class="card">
    <div class="row"><div>Log</div>
      <div>
        <pre id="log"></pre>
        <button id="copyLogs">Copy Logs</button>
      </div>
    </div>
  </div>
  <script>
    (function(){
      const url = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws-tunnel';
      document.getElementById('ep').textContent = url;
      const status = document.getElementById('status');
      const logEl = document.getElementById('log');
      const rttEl = document.getElementById('rtt');
      const sendBtn = document.getElementById('send');
      const reconnectBtn = document.getElementById('reconnect');
      const copyLogsBtn = document.getElementById('copyLogs');
      const fileSelect = document.getElementById('fileSelect');
      const downloadBtn = document.getElementById('downloadBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');
      const transferInfo = document.getElementById('transferInfo');
      const transferProg = document.getElementById('transferProg');
      const MAX_LOG_LINES = 100;
      const logLines = [];
      const log = (m) => { 
        const s = new Date().toISOString() + ' ' + m; 
        console.log(s); 
        logLines.push(s);
        if (logLines.length > MAX_LOG_LINES) logLines.shift();
        logEl.textContent = logLines.join('\n'); 
        logEl.scrollTop = logEl.scrollHeight; 
      };
      const setSend = (on) => {
        sendBtn.disabled = !on;
        downloadBtn.disabled = !on;
        fileSelect.disabled = !on;
        deleteBtn.disabled = !on;
        fileInput.disabled = !on;
        uploadBtn.disabled = !on;
      };
      const mean = (a) => a.length ? a.reduce((x, y) => x + y, 0) / a.length : 0;
      copyLogsBtn.onclick = async () => {
        try { 
          await navigator.clipboard.writeText(logEl.textContent); 
          log('Logs copied to clipboard'); 
        } catch (e) {
          log('Copy failed: ' + e.message);
          const t = document.createElement('textarea'); 
          t.value = logEl.textContent; 
          document.body.appendChild(t); 
          t.select(); 
          document.execCommand('copy'); 
          t.remove();
          log('Logs copied using fallback');
        }
      };
      let ws, sent = new Map(), rtts = [], reconnectAttempts = 0;
      let rx = null, tx = null;
      function b64ToBytes(b64) {
        const start = performance.now();
        try {
          const bin = atob(b64); 
          const len = bin.length;
          const out = new Uint8Array(len);
          for (let i = 0; i < len; i++) out[i] = bin.charCodeAt(i);
          log(`b64ToBytes decoded ${len} bytes took ${(performance.now() - start).toFixed(1)}ms`);
          return out;
        } catch (e) {
          log('b64ToBytes error: ' + e.message);
          return new Uint8Array(0);
        }
      }
      function resetTransfer() { 
        rx = null; 
        tx = null;
        transferInfo.textContent = 'Waiting...'; 
        transferProg.value = 0; 
      }
      async function fetchFiles() {
        try {
          const res = await fetch('/files');
          if (!res.ok) throw new Error('Failed to fetch files: ' + res.status);
          const files = await res.json();
          fileSelect.innerHTML = '<option value="">Select a file...</option>';
          files.forEach(file => {
            const opt = document.createElement('option');
            opt.value = file.name;
            opt.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
            fileSelect.appendChild(opt);
          });
          log('Fetched file list: ' + files.map(f => f.name).join(', '));
        } catch (e) {
          log('Fetch files error: ' + e.message);
          fileSelect.innerHTML = '<option value="">No files available</option>';
        }
      }
      function cleanupSentMap() {
        const now = performance.now();
        for (const [id, t0] of sent) {
          if (now - t0 > 5000) {
            log(`PING timeout id=${id}`);
            sent.delete(id);
          }
        }
      }
      function connect() {
        log('Attempting connection to ' + url + ' (attempt ' + (reconnectAttempts + 1) + ')');
        ws = new WebSocket(url, ['tunnel'], { perMessageDeflate: false, headers: { 'Sec-WebSocket-Extensions': 'none' } });
        ws.onopen = () => { 
          status.innerHTML = '<span class="ok">OPEN</span>'; 
          log('OPEN ' + url); 
          setSend(true); 
          reconnectAttempts = 0;
          fetchFiles();
          try {
            const id1 = Math.random().toString(36).slice(2);
            sent.set(id1, performance.now());
            ws.send(JSON.stringify({ type: 'ping', id: id1, clientTs: Date.now() }));
            log('Client sent initial ping id=' + id1);
            setTimeout(() => {
              if (ws.readyState === ws.OPEN) {
                const id2 = Math.random().toString(36).slice(2);
                sent.set(id2, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id: id2, clientTs: Date.now() }));
                log('Client sent second ping id=' + id2);
              }
            }, 50);
          } catch (e) { 
            log('Client send error: ' + e.message); 
          }
          const heartbeat = setInterval(() => {
            if (ws.readyState === ws.OPEN) {
              try {
                const id = Math.random().toString(36).slice(2);
                sent.set(id, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() }));
                log('Client heartbeat ping id=' + id);
                cleanupSentMap();
              } catch (e) {
                log('Client heartbeat error: ' + e.message);
              }
            } else {
              clearInterval(heartbeat);
            }
          }, 2000);
        };
        ws.onerror = () => { 
          log('ERROR (browser hides details)'); 
          status.innerHTML = '<span class="bad">ERROR</span> - Check logs or try direct download';
          setSend(false);
        };
        ws.onclose = (e) => {
          status.innerHTML = '<span class="bad">CLOSED</span> code=' + e.code; 
          setSend(false); 
          log('CLOSE code=' + e.code + ' reason="' + e.reason + '"');
          reconnectAttempts++;
          const delay = Math.min(20000, 5000 + reconnectAttempts * 3000);
          log('Reconnecting in ' + delay + 'ms');
          setTimeout(connect, delay);
        };
        ws.onmessage = (ev) => {
          const start = performance.now();
          log('MESSAGE received length=' + ev.data.length + ' content=' + ev.data.slice(0, 200));
          let m = null; 
          try { 
            m = JSON.parse(ev.data); 
          } catch { 
            return log('TEXT ' + String(ev.data).slice(0, 200)); 
          }
          if (m.type === 'welcome') { 
            log('WELCOME id=' + m.clientId + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m.type === 'serverPing') { 
            log('serverPing ' + m.serverTs); 
            return; 
          }
          if (m.type === 'error') { 
            log('ERROR ' + m.message); 
            transferInfo.textContent = 'Error: ' + m.message;
            resetTransfer();
            return; 
          }
          if (m.type === 'pong') {
            const t0 = sent.get(m.id);
            if (t0) { 
              const dt = performance.now() - t0; 
              if (dt <= 5000) {
                rtts.push(dt); 
                if (rtts.length > 20) rtts.shift(); 
                rttEl.textContent = mean(rtts).toFixed(1) + 'ms'; 
              } else {
                log(`PONG ignored (RTT=${dt.toFixed(1)}ms too high) id=${m.id}`);
              }
              sent.delete(m.id); 
            }
            log('PONG id=' + m.id + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m.type === 'fileMeta') {
            resetTransfer();
            rx = {
              name: m.name || 'download.bin',
              size: Number(m.size) || 0,
              mime: m.mime || 'application/octet-stream',
              totalChunks: Number(m.chunks) || 0,
              chunkSize: Number(m.chunkSize) || 0,
              offset: 0,
              gotChunks: 0,
              buf: new Uint8Array(Number(m.size) || 0)
            };
            transferInfo.textContent = `Receiving ${rx.name} (${rx.size} bytes) in ${rx.totalChunks} chunks...`;
            transferProg.max = rx.size || 100;
            log('FILE META ' + JSON.stringify(m));
            try {
              const id = Math.random().toString(36).slice(2);
              sent.set(id, performance.now());
              ws.send(JSON.stringify({ type: 'ready', id, clientTs: Date.now() }));
              log('Client sent ready id=' + id);
            } catch (e) { 
              log('Client ready error: ' + e.message); 
            }
            return;
          }
          if (m.type === 'fileChunk' && rx) {
            try {
              const bytes = b64ToBytes(m.data || '');
              if (bytes.length === 0) {
                log('FILE CHUNK empty or invalid');
                return;
              }
              rx.buf.set(bytes, rx.offset);
              rx.offset += bytes.length;
              rx.gotChunks++;
              if (rx.size) transferProg.value = rx.offset;
              if ((rx.gotChunks % 16) === 0 || rx.gotChunks === rx.totalChunks) {
                log(`FILE CHUNK ${rx.gotChunks}/${rx.totalChunks} (+${bytes.length}B) offset=${rx.offset}`);
              }
            } catch (e) {
              log('FILE CHUNK error: ' + e.message);
              transferInfo.textContent = 'Download failed: ' + e.message;
            }
            return;
          }
          if (m.type === 'fileEnd' && rx) {
            log('FILE END ok=' + (!!m.ok) + ' total=' + rx.offset + ' bytes took ' + (performance.now() - start).toFixed(1) + 'ms');
            try {
              if (rx.offset !== rx.size) {
                throw new Error(`Size mismatch: expected ${rx.size}, got ${rx.offset}`);
              }
              const blob = new Blob([rx.buf], { type: rx.mime });
              const a = document.createElement('a');
              a.href = URL.createObjectURL(blob);
              a.download = rx.name;
              document.body.appendChild(a);
              a.click();
              setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 15000);
              transferInfo.textContent = 'Downloaded: ' + rx.name + ' (' + rx.offset + ' bytes)';
              fetchFiles();
            } catch (e) {
              log('DOWNLOAD trigger failed: ' + e.message);
              transferInfo.textContent = 'Download failed: ' + e.message;
            }
            resetTransfer();
            return;
          }
          if (m.type === 'uploadComplete') {
            log('UPLOAD COMPLETE id=' + m.id + ' file=' + m.fileName + ' size=' + m.size);
            transferInfo.textContent = 'Uploaded: ' + m.fileName + ' (' + m.size + ' bytes)';
            resetTransfer();
            fetchFiles();
            return;
          }
          if (m.type === 'deleteComplete') {
            log('DELETE COMPLETE id=' + m.id + ' file=' + m.fileName);
            transferInfo.textContent = 'Deleted: ' + m.fileName;
            fetchFiles();
            return;
          }
          if (m.type === 'say') { 
            log('SAY ' + JSON.stringify(m)); 
            return; 
          }
          log('MSG ' + JSON.stringify(m));
        };
      }
      downloadBtn.onclick = () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('DOWNLOAD blocked (socket not open)'); 
          return; 
        }
        const fileName = fileSelect.value;
        if (!fileName) {
          log('DOWNLOAD blocked (no file selected)');
          return;
        }
        try {
          const id = Math.random().toString(36).slice(2);
          ws.send(JSON.stringify({ type: 'requestFile', id, fileName, clientTs: Date.now() }));
          log('Client requested file id=' + id + ' file=' + fileName);
        } catch (e) {
          log('Download request error: ' + e.message);
        }
      };
      deleteBtn.onclick = () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('DELETE blocked (socket not open)'); 
          return; 
        }
        const fileName = fileSelect.value;
        if (!fileName) {
          log('DELETE blocked (no file selected)');
          return;
        }
        try {
          const id = Math.random().toString(36).slice(2);
          ws.send(JSON.stringify({ type: 'deleteFile', id, fileName, clientTs: Date.now() }));
          log('Client requested delete id=' + id + ' file=' + fileName);
        } catch (e) {
          log('Delete request error: ' + e.message);
        }
      };
      uploadBtn.onclick = async () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('UPLOAD blocked (socket not open)'); 
          return; 
        }
        const file = fileInput.files[0];
        if (!file) {
          log('UPLOAD blocked (no file selected)');
          return;
        }
        const id = Math.random().toString(36).slice(2);
        const chunkSize = 64 * 1024;
        const totalChunks = Math.ceil(file.size / chunkSize);
        tx = { id, fileName: file.name, size: file.size, totalChunks, chunkSize, sentChunks: 0 };
        transferInfo.textContent = `Uploading ${tx.fileName} (${tx.size} bytes) in ${tx.totalChunks} chunks...`;
        transferProg.max = tx.size;
        log(`Starting upload for ${tx.fileName} size=${tx.size} chunks=${tx.totalChunks}`);
        const reader = new FileReader();
        for (let i = 0; i < totalChunks; i++) {
          const start = i * chunkSize;
          const end = Math.min(file.size, start + chunkSize);
          const slice = file.slice(start, end);
          await new Promise((resolve) => {
            reader.onload = (e) => {
              const b64 = e.target.result.split(',')[1] || ''; // Ensure valid base64
              if (!b64) {
                log(`UPLOAD chunk ${i + 1} failed: empty base64 data`);
                transferInfo.textContent = 'Upload failed: empty chunk data';
                resetTransfer();
                return;
              }
              try {
                ws.send(JSON.stringify({ type: 'uploadFile', id, fileName: file.name, seq: i, data: b64, totalChunks, size: file.size, mime: file.type || 'application/octet-stream', clientTs: Date.now() }));
                tx.sentChunks++;
                transferProg.value = end;
                log(`UPLOAD chunk ${tx.sentChunks}/${tx.totalChunks} (+${end - start}B)`);
                setTimeout(resolve, 50);
              } catch (e) {
                log('UPLOAD chunk error: ' + e.message);
                transferInfo.textContent = 'Upload failed: ' + e.message;
                resetTransfer();
              }
            };
            reader.onerror = () => {
              log('FileReader error: ' + reader.error.message);
              transferInfo.textContent = 'Upload failed: FileReader error';
              resetTransfer();
            };
            reader.readAsDataURL(slice);
          });
        }
      };
      sendBtn.onclick = () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('SEND blocked (socket not open)'); 
          return; 
        }
        const text = (input.value || 'ping').trim();
        if (text.toLowerCase() === 'ping') {
          const id = Math.random().toString(36).slice(2);
          sent.set(id, performance.now());
          try { 
            ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() })); 
            log('PING id=' + id); 
          } catch (e) { 
            log('Send ping error: ' + e.message); 
          }
        } else {
          try { 
            ws.send(JSON.stringify({ type: 'say', text, clientTs: Date.now() })); 
            log('SEND text=' + text); 
          } catch (e) { 
            log('Send text error: ' + e.message); 
          }
        }
        input.value = '';
      };
      reconnectBtn.onclick = () => { 
        try { if (ws) ws.close(); } catch {} 
        connect(); 
      };
      connect();
    })();
  </script>
</body>
</html>
