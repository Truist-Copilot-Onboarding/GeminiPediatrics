<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WS Tunnel (Heroku)</title>
  <style>
    :root { 
      color-scheme: light dark; 
      --primary: #1e90ff;
      --success: #28a745;
      --error: #dc3545;
      --bg: #f8f9fa;
      --card-bg: #fff;
      --text: #333;
      --muted: #6c757d;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #222;
        --card-bg: #333;
        --text: #ddd;
        --muted: #aaa;
      }
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 2rem;
      max-width: 960px;
      margin: auto;
      background: var(--bg);
      color: var(--text);
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 1rem;
      color: var(--primary);
    }
    .muted { color: var(--muted); }
    .card {
      background: var(--card-bg);
      border: 1px solid #ccc3;
      border-radius: 10px;
      padding: 1.5rem;
      margin: 1rem 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .row {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .row label {
      width: 120px;
      font-weight: 500;
    }
    .row > div { flex: 1; }
    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    input, select, button {
      font: inherit;
      padding: 0.5rem 1rem;
      border: 1px solid #ccc;
      border-radius: 5px;
      background: #fff;
      color: var(--text);
    }
    button {
      background: var(--primary);
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover:not(:disabled) {
      background: #1c86ee;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .delete-btn {
      background: var(--error);
    }
    .delete-btn:hover:not(:disabled) {
      background: #c82333;
    }
    .ok { color: var(--success); }
    .bad { color: var(--error); }
    pre {
      background: #1a1a1a;
      color: #0f0;
      padding: 1rem;
      border-radius: 5px;
      max-height: 300px;
      overflow: auto;
      font-family: ui-monospace, monospace;
      font-size: 0.9rem;
    }
    progress {
      width: 100%;
      height: 1.2rem;
      border-radius: 5px;
    }
    a { color: var(--primary); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>WebSocket Tunnel (Heroku)</h1>
  <p class="muted">
    Connects to <code>/ws-tunnel</code>. Echo at <code>/ws-echo</code>. Live logs at <a href="/console" target="_blank">/console</a>.<br>
    File download: <a href="/files/HelloWorld.zip" target="_blank">/files/HelloWorld.zip</a> (example).
  </p>
  <div class="card">
    <div class="row">
      <label>Endpoint</label>
      <div><code id="ep"></code></div>
    </div>
    <div class="row">
      <label>Status</label>
      <div id="status">Connecting...</div>
    </div>
    <div class="row">
      <label>RTT (avg)</label>
      <div id="rtt">--</div>
    </div>
  </div>
  <div class="card">
    <div class="row">
      <label>Send Message</label>
      <div class="controls">
        <input id="msg" placeholder="Type text (or 'ping')" style="flex: 1"/>
        <button id="send" disabled>Send</button>
        <button id="reconnect">Reconnect</button>
      </div>
    </div>
    <div class="row">
      <label>File Operations</label>
      <div class="controls">
        <select id="fileSelect" disabled>
          <option value="">Select a file...</option>
        </select>
        <button id="downloadBtn" disabled>Download</button>
        <button id="deleteBtn" disabled class="delete-btn">Delete</button>
      </div>
    </div>
    <div class="row">
      <label>Upload File</label>
      <div class="controls">
        <input type="file" id="fileInput" disabled/>
        <button id="uploadBtn" disabled>Upload</button>
      </div>
    </div>
    <div class="row">
      <label>Transfer Progress</label>
      <div>
        <div id="transferInfo" class="muted">Waiting...</div>
        <progress id="transferProg" max="100" value="0"></progress>
      </div>
    </div>
  </div>
  <div class="card">
    <div class="row">
      <label>Client Logs</label>
      <div>
        <pre id="log"></pre>
        <button id="copyLogs">Copy Logs</button>
      </div>
    </div>
  </div>
  <script>
    (function(){
      const url = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws-tunnel';
      document.getElementById('ep').textContent = url;
      const status = document.getElementById('status');
      const logEl = document.getElementById('log');
      const rttEl = document.getElementById('rtt');
      const sendBtn = document.getElementById('send');
      const reconnectBtn = document.getElementById('reconnect');
      const copyLogsBtn = document.getElementById('copyLogs');
      const fileSelect = document.getElementById('fileSelect');
      const downloadBtn = document.getElementById('downloadBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');
      const transferInfo = document.getElementById('transferInfo');
      const transferProg = document.getElementById('transferProg');
      const MAX_LOG_LINES = 100;
      const logLines = [];
      const debounce = (fn, delay) => {
        let timeout;
        return (...args) => {
          if (timeout) return;
          timeout = setTimeout(() => {
            fn(...args);
            timeout = null;
          }, delay);
        };
      };
      const disableDuringTransfer = (fn) => {
        return (...args) => {
          if (rx || tx) {
            log('Action blocked: transfer in progress');
            return;
          }
          fn(...args);
        };
      };
      const log = (m) => { 
        const s = new Date().toISOString() + ' ' + m; 
        console.log(s); 
        logLines.push(s);
        if (logLines.length > MAX_LOG_LINES) logLines.shift();
        logEl.textContent = logLines.join('\n'); 
        logEl.scrollTop = logEl.scrollHeight; 
      };
      const setSend = (on) => {
        sendBtn.disabled = !on;
        downloadBtn.disabled = !on || (rx || tx);
        fileSelect.disabled = !on;
        deleteBtn.disabled = !on || (rx || tx);
        fileInput.disabled = !on || (rx || tx);
        uploadBtn.disabled = !on || (rx || tx);
      };
      const mean = (a) => a.length ? a.reduce((x, y) => x + y, 0) / a.length : 0;
      copyLogsBtn.onclick = debounce(async () => {
        try { 
          await navigator.clipboard.writeText(logEl.textContent); 
          log('Logs copied to clipboard'); 
        } catch (e) {
          log('Copy failed: ' + e.message);
          const t = document.createElement('textarea'); 
          t.value = logEl.textContent; 
          document.body.appendChild(t); 
          t.select(); 
          document.execCommand('copy'); 
          t.remove();
          log('Logs copied using fallback');
        }
      }, 500);
      let ws, sent = new Map(), rtts = [], reconnectAttempts = 0;
      let rx = null, tx = null;
      function resetTransfer() { 
        rx = null; 
        tx = null;
        transferInfo.textContent = 'Waiting...'; 
        transferProg.value = 0; 
        transferProg.max = 100;
        setSend(ws && ws.readyState === ws.OPEN);
      }
      async function fetchFiles() {
        try {
          const res = await fetch('/files');
          if (!res.ok) throw new Error('Failed to fetch files: ' + res.status);
          const files = await res.json();
          fileSelect.innerHTML = '<option value="">Select a file...</option>';
          files.forEach(file => {
            const opt = document.createElement('option');
            opt.value = file.name;
            opt.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
            fileSelect.appendChild(opt);
          });
          log('Fetched file list: ' + files.map(f => f.name).join(', '));
        } catch (e) {
          log('Fetch files error: ' + e.message);
          fileSelect.innerHTML = '<option value="">No files available</option>';
        }
      }
      function cleanupSentMap() {
        const now = performance.now();
        for (const [id, t0] of sent) {
          if (now - t0 > 5000) {
            log(`PING timeout id=${id}`);
            sent.delete(id);
          }
        }
      }
      function connect() {
        log('Attempting connection to ' + url + ' (attempt ' + (reconnectAttempts + 1) + ')');
        ws = new WebSocket(url, ['tunnel'], { perMessageDeflate: false, headers: { 'Sec-WebSocket-Extensions': 'none' } });
        ws.onopen = () => { 
          status.innerHTML = '<span class="ok">OPEN</span>'; 
          log('OPEN ' + url); 
          setSend(true); 
          reconnectAttempts = 0;
          fetchFiles();
          try {
            const id1 = Math.random().toString(36).slice(2);
            sent.set(id1, performance.now());
            ws.send(JSON.stringify({ type: 'ping', id: id1, clientTs: Date.now() }));
            log('Client sent initial ping id=' + id1);
            setTimeout(() => {
              if (ws.readyState === ws.OPEN) {
                const id2 = Math.random().toString(36).slice(2);
                sent.set(id2, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id: id2, clientTs: Date.now() }));
                log('Client sent second ping id=' + id2);
              }
            }, 50);
          } catch (e) { 
            log('Client send error: ' + e.message); 
          }
          const heartbeat = setInterval(() => {
            if (ws.readyState === ws.OPEN) {
              try {
                const id = Math.random().toString(36).slice(2);
                sent.set(id, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() }));
                log('Client heartbeat ping id=' + id);
                cleanupSentMap();
              } catch (e) {
                log('Client heartbeat error: ' + e.message);
              }
            } else {
              clearInterval(heartbeat);
            }
          }, 2000);
        };
        ws.onerror = () => { 
          log('ERROR (browser hides details)'); 
          status.innerHTML = '<span class="bad">ERROR</span> - Check logs or try direct download';
          setSend(false);
        };
        ws.onclose = (e) => {
          status.innerHTML = '<span class="bad">CLOSED</span> code=' + e.code; 
          setSend(false); 
          log('CLOSE code=' + e.code + ' reason="' + e.reason + '"');
          reconnectAttempts++;
          const delay = Math.min(20000, 5000 + reconnectAttempts * 3000);
          log('Reconnecting in ' + delay + 'ms');
          setTimeout(connect, delay);
        };
        ws.onmessage = (ev) => {
          const start = performance.now();
          log('MESSAGE received length=' + ev.data.length + ' content=' + ev.data.slice(0, 200));
          let m = null; 
          try { 
            m = JSON.parse(ev.data); 
          } catch { 
            return log('TEXT ' + String(ev.data).slice(0, 200)); 
          }
          if (m.type === 'welcome') { 
            log('WELCOME id=' + m.clientId + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m.type === 'serverPing') { 
            log('serverPing ' + m.serverTs); 
            return; 
          }
          if (m.type === 'error') { 
            log('ERROR ' + m.message); 
            transferInfo.textContent = 'Error: ' + m.message;
            resetTransfer();
            return; 
          }
          if (m.type === 'pong') {
            const t0 = sent.get(m.id);
            if (t0) { 
              const dt = performance.now() - t0; 
              if (dt <= 5000) {
                rtts.push(dt); 
                if (rtts.length > 20) rtts.shift(); 
                rttEl.textContent = mean(rtts).toFixed(1) + 'ms'; 
              } else {
                log(`PONG ignored (RTT=${dt.toFixed(1)}ms too high) id=${m.id}`);
              }
              sent.delete(m.id); 
            }
            log('PONG id=' + m.id + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m.type === 'fileMeta') {
            resetTransfer();
            rx = {
              name: m.name || 'download.bin',
              size: Number(m.size) || 0,
              mime: m.mime || 'application/octet-stream',
              totalChunks: Number(m.chunks) || 0,
              chunkSize: Number(m.chunkSize) || 0,
              offset: 0,
              gotChunks: 0,
              buf: new Uint8Array(Number(m.size) || 0)
            };
            transferInfo.textContent = `Receiving ${rx.name} (${rx.size} bytes) in ${rx.totalChunks} chunks...`;
            transferProg.max = rx.size || 1;
            log('FILE META ' + JSON.stringify(m));
            try {
              const id = Math.random().toString(36).slice(2);
              sent.set(id, performance.now());
              ws.send(JSON.stringify({ type: 'ready', id, clientTs: Date.now() }));
              log('Client sent ready id=' + id);
            } catch (e) { 
              log('Client ready error: ' + e.message); 
            }
            return;
          }
          if (m.type === 'fileChunk' && rx) {
            try {
              const bytes = new Uint8Array(JSON.parse(m.data));
              if (bytes.length === 0) {
                log('FILE CHUNK empty or invalid');
                return;
              }
              rx.buf.set(bytes, rx.offset);
              rx.offset += bytes.length;
              rx.gotChunks++;
              transferProg.value = rx.offset;
              if ((rx.gotChunks % 16) === 0 || rx.gotChunks === rx.totalChunks) {
                log(`FILE CHUNK ${rx.gotChunks}/${rx.totalChunks} (+${bytes.length}B) offset=${rx.offset}`);
              }
            } catch (e) {
              log('FILE CHUNK error: ' + e.message);
              transferInfo.textContent = 'Download failed: ' + e.message;
            }
            return;
          }
          if (m.type === 'fileEnd' && rx) {
            log('FILE END ok=' + (!!m.ok) + ' total=' + rx.offset + ' bytes took ' + (performance.now() - start).toFixed(1) + 'ms');
            try {
              if (rx.offset !== rx.size) {
                throw new Error(`Size mismatch: expected ${rx.size}, got ${rx.offset}`);
              }
              const blob = new Blob([rx.buf], { type: rx.mime });
              log(`Created Blob size=${blob.size} type=${rx.mime}`);
              const a = document.createElement('a');
              a.href = URL.createObjectURL(blob);
              a.download = rx.name;
              document.body.appendChild(a);
              a.click();
              setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 30000); // Increased timeout
              transferInfo.textContent = 'Downloaded: ' + rx.name + ' (' + rx.offset + ' bytes)';
              fetchFiles();
            } catch (e) {
              log('DOWNLOAD trigger failed: ' + e.message);
              transferInfo.textContent = 'Download failed: ' + e.message + '. Try <a href="/files/' + rx.name + '">direct download</a>.';
            }
            resetTransfer();
            return;
          }
          if (m.type === 'uploadComplete') {
            log('UPLOAD COMPLETE id=' + m.id + ' file=' + m.fileName + ' size=' + m.size);
            transferInfo.textContent = 'Uploaded: ' + m.fileName + ' (' + m.size + ' bytes)';
            resetTransfer();
            fetchFiles();
            return;
          }
          if (m.type === 'deleteComplete') {
            log('DELETE COMPLETE id=' + m.id + ' file=' + m.fileName);
            transferInfo.textContent = 'Deleted: ' + m.fileName;
            resetTransfer();
            fetchFiles();
            return;
          }
          if (m.type === 'say') { 
            log('SAY ' + JSON.stringify(m)); 
            return; 
          }
          log('MSG ' + JSON.stringify(m));
        };
      }
      downloadBtn.onclick = debounce(disableDuringTransfer(() => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('DOWNLOAD blocked (socket not open)'); 
          return; 
        }
        const fileName = fileSelect.value;
        if (!fileName) {
          log('DOWNLOAD blocked (no file selected)');
          return;
        }
        try {
          const id = Math.random().toString(36).slice(2);
          ws.send(JSON.stringify({ type: 'requestFile', id, fileName, clientTs: Date.now() }));
          log('Client requested file id=' + id + ' file=' + fileName);
        } catch (e) {
          log('Download request error: ' + e.message);
        }
      }), 500);
      deleteBtn.onclick = debounce(disableDuringTransfer(() => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('DELETE blocked (socket not open)'); 
          return; 
        }
        const fileName = fileSelect.value;
        if (!fileName) {
          log('DELETE blocked (no file selected)');
          return;
        }
        if (!confirm(`Are you sure you want to delete ${fileName}?`)) {
          log('DELETE cancelled by user');
          return;
        }
        try {
          const id = Math.random().toString(36).slice(2);
          ws.send(JSON.stringify({ type: 'deleteFile', id, fileName, clientTs: Date.now() }));
          log('Client requested delete id=' + id + ' file=' + fileName);
        } catch (e) {
          log('Delete request error: ' + e.message);
        }
      }), 500);
      uploadBtn.onclick = debounce(disableDuringTransfer(async () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('UPLOAD blocked (socket not open)'); 
          return; 
        }
        const file = fileInput.files[0];
        if (!file) {
          log('UPLOAD blocked (no file selected)');
          return;
        }
        const id = Math.random().toString(36).slice(2);
        const chunkSize = 64 * 1024;
        const totalChunks = Math.ceil(file.size / chunkSize);
        tx = { id, fileName: file.name, size: file.size, totalChunks, chunkSize, sentChunks: 0 };
        transferInfo.textContent = `Uploading ${tx.fileName} (${tx.size} bytes) in ${tx.totalChunks} chunks...`;
        transferProg.max = tx.size || 1;
        log(`Starting upload for ${tx.fileName} size=${tx.size} chunks=${tx.totalChunks}`);
        const reader = new FileReader();
        for (let i = 0; i < totalChunks; i++) {
          const start = i * chunkSize;
          const end = Math.min(file.size, start + chunkSize);
          const slice = file.slice(start, end);
          await new Promise((resolve) => {
            reader.onload = (e) => {
              const arrayBuffer = e.target.result;
              const bytes = new Uint8Array(arrayBuffer);
              if (bytes.length === 0) {
                log(`UPLOAD chunk ${i + 1} failed: empty data`);
                transferInfo.textContent = 'Upload failed: empty chunk data';
                resetTransfer();
                return;
              }
              try {
                ws.send(JSON.stringify({ type: 'uploadFile', id, fileName: file.name, seq: i, data: Array.from(bytes), totalChunks, size: file.size, mime: file.type || 'application/octet-stream', clientTs: Date.now() }));
                tx.sentChunks++;
                transferProg.value = end;
                log(`UPLOAD chunk ${tx.sentChunks}/${tx.totalChunks} (+${bytes.length}B)`);
                setTimeout(resolve, 50);
              } catch (e) {
                log('UPLOAD chunk error: ' + e.message);
                transferInfo.textContent = 'Upload failed: ' + e.message;
                resetTransfer();
              }
            };
            reader.onerror = () => {
              log('FileReader error: ' + reader.error.message);
              transferInfo.textContent = 'Upload failed: FileReader error';
              resetTransfer();
            };
            reader.readAsArrayBuffer(slice);
          });
        }
      }), 500);
      sendBtn.onclick = debounce(() => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('SEND blocked (socket not open)'); 
          return; 
        }
        const text = (input.value || 'ping').trim();
        if (text.toLowerCase() === 'ping') {
          const id = Math.random().toString(36).slice(2);
          sent.set(id, performance.now());
          try { 
            ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() })); 
            log('PING id=' + id); 
          } catch (e) { 
            log('Send ping error: ' + e.message); 
          }
        } else {
          try { 
            ws.send(JSON.stringify({ type: 'say', text, clientTs: Date.now() })); 
            log('SEND text=' + text); 
          } catch (e) { 
            log('Send text error: ' + e.message); 
          }
        }
        input.value = '';
      }, 500);
      reconnectBtn.onclick = debounce(() => { 
        try { if (ws) ws.close(); } catch {} 
        connect(); 
      }, 500);
      connect();
    })();
  </script>
</body>
</html>
