<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WS Tunnel (Heroku)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui; padding: 2rem; max-width: 960px; margin: auto; }
    .row { display: grid; grid-template-columns: 140px 1fr; gap: 0.5rem 1rem; align-items: center; }
    .card { border: 1px solid #ccc3; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .ok { color: #0b7; } .bad { color: #b22; } .muted { opacity: 0.8; }
    pre { background: #111; color: #0f0; padding: 12px; border-radius: 8px; white-space: pre-wrap; max-height: 260px; overflow: auto; }
    input, button { font: inherit; padding: 0.45rem; }
    button:disabled { opacity: 0.5; }
    a { color: inherit; }
    progress { width: 100%; }
  </style>
</head>
<body>
  <h1>WebSocket Tunnel (Heroku)</h1>
  <p class="muted">
    Connects to <code>/ws-tunnel</code>. Echo at <code>/ws-echo</code>. Live logs at <a href="/console" target="_blank">/console</a>.<br>
    File download: <a href="/HelloWorld.exe" target="_blank">/HelloWorld.exe</a>.
  </p>
  <div class="row"><div>Endpoint</div><div><code id="ep"></code></div></div>
  <div class="row"><div>Status</div><div id="status">Connecting...</div></div>
  <div class="row"><div>RTT (avg)</div><div id="rtt">--</div></div>
  <div class="card">
    <div class="row"><div>Send</div>
      <div>
        <input id="msg" placeholder="Type text (or 'ping')"/>
        <button id="send" disabled>Send</button>
        <button id="reconnect">Reconnect</button>
        <button id="downloadBtn" disabled>Download File</button>
      </div>
    </div>
    <div class="row"><div>Download Progress</div>
      <div>
        <div id="pdfInfo" class="muted">Waiting...</div>
        <progress id="pdfProg" max="100" value="0"></progress>
      </div>
    </div>
  </div>
  <div class="card">
    <div class="row"><div>Log</div>
      <div>
        <pre id="log"></pre>
        <button id="copyLogs">Copy Logs</button>
      </div>
    </div>
  </div>
  <script>
    (function(){
      const url = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws-tunnel';
      document.getElementById('ep').textContent = url;
      const status = document.getElementById('status');
      const logEl = document.getElementById('log');
      const rttEl = document.getElementById('rtt');
      const sendBtn = document.getElementById('send');
      const reconnectBtn = document.getElementById('reconnect');
      const copyLogsBtn = document.getElementById('copyLogs');
      const downloadBtn = document.getElementById('downloadBtn');
      const input = document.getElementById('msg');
      const pdfInfo = document.getElementById('pdfInfo');
      const pdfProg = document.getElementById('pdfProg');
      const log = (m) => { 
        const s = new Date().toISOString() + ' ' + m; 
        console.log(s); 
        logEl.textContent += s + "\n"; 
        logEl.scrollTop = logEl.scrollHeight; 
      };
      const setSend = (on) => {
        sendBtn.disabled = !on;
        downloadBtn.disabled = !on;
      };
      const mean = (a) => a.length ? a.reduce((x, y) => x + y, 0) / a.length : 0;
      copyLogsBtn.onclick = async () => {
        try { 
          await navigator.clipboard.writeText(logEl.textContent); 
          log('Logs copied to clipboard'); 
        } catch (e) {
          log('Copy failed: ' + e.message);
          const t = document.createElement('textarea'); 
          t.value = logEl.textContent; 
          document.body.appendChild(t); 
          t.select(); 
          document.execCommand('copy'); 
          t.remove();
          log('Logs copied using fallback');
        }
      };
      let ws, sent = new Map(), rtts = [], reconnectAttempts = 0;
      let rx = null, fileHandle = null, writable = null;
      function resetRx() { 
        if (writable) {
          writable.close().catch(e => log('OPFS close error: ' + e.message));
        }
        rx = null; 
        fileHandle = null;
        writable = null;
        pdfInfo.textContent = 'Waiting...'; 
        pdfProg.value = 0; 
        pdfProg.max = 100;
      }
      async function connect() {
        log('Attempting connection to ' + url + ' (attempt ' + (reconnectAttempts + 1) + ')');
        ws = new WebSocket(url, ['tunnel'], { perMessageDeflate: false, headers: { 'Sec-WebSocket-Extensions': 'none' } });
        ws.binaryType = 'arraybuffer';
        ws.onopen = () => { 
          status.innerHTML = '<span class="ok">OPEN</span>'; 
          log('OPEN ' + url); 
          setSend(true); 
          reconnectAttempts = 0;
          try {
            const id1 = Math.random().toString(36).slice(2);
            sent.set(id1, performance.now());
            ws.send(JSON.stringify({ type: 'ping', id: id1, clientTs: Date.now() }));
            log('Client sent initial ping id=' + id1);
            setTimeout(() => {
              if (ws.readyState === ws.OPEN) {
                const id2 = Math.random().toString(36).slice(2);
                sent.set(id2, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id: id2, clientTs: Date.now() }));
                log('Client sent second ping id=' + id2);
              }
            }, 50);
          } catch (e) { 
            log('Client send error: ' + e.message); 
          }
          const heartbeat = setInterval(() => {
            if (ws.readyState === ws.OPEN) {
              try {
                const id = Math.random().toString(36).slice(2);
                sent.set(id, performance.now());
                ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() }));
                log('Client heartbeat ping id=' + id);
              } catch (e) {
                log('Client heartbeat error: ' + e.message);
              }
            } else {
              clearInterval(heartbeat);
            }
          }, 500);
        };
        ws.onerror = () => { 
          log('ERROR (browser hides details)'); 
          status.innerHTML = '<span class="bad">ERROR</span> - Check logs or try <a href="/HelloWorld.exe">direct download</a>';
          setSend(false);
        };
        ws.onclose = (e) => {
          status.innerHTML = '<span class="bad">CLOSED</span> code=' + e.code; 
          setSend(false); 
          log('CLOSE code=' + e.code + ' reason="' + e.reason + '"');
          reconnectAttempts++;
          const delay = Math.min(20000, 5000 + reconnectAttempts * 3000);
          log('Reconnecting in ' + delay + 'ms');
          setTimeout(connect, delay);
        };
        ws.onmessage = async (ev) => {
          const start = performance.now();
          let m = null;
          if (typeof ev.data === 'string') {
            log('MESSAGE received text length=' + ev.data.length + ' content=' + ev.data.slice(0, 200));
            try { 
              m = JSON.parse(ev.data); 
            } catch { 
              return log('TEXT ' + String(ev.data).slice(0, 200)); 
            }
          } else {
            log('MESSAGE received binary length=' + ev.data.byteLength);
          }
          if (m && m.type === 'welcome') { 
            log('WELCOME id=' + m.clientId + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m && m.type === 'serverPing') { 
            log('serverPing ' + m.serverTs); 
            return; 
          }
          if (m && m.type === 'error') { 
            log('ERROR ' + m.message); 
            pdfInfo.textContent = 'Error: ' + m.message;
            resetRx();
            return; 
          }
          if (m && m.type === 'pong') {
            const t0 = sent.get(m.id);
            if (t0) { 
              const dt = performance.now() - t0; 
              rtts.push(dt); 
              if (rtts.length > 20) rtts.shift(); 
              rttEl.textContent = mean(rtts).toFixed(1) + ' ms'; 
              sent.delete(m.id); 
            }
            log('PONG id=' + m.id + ' serverT=' + m.serverTs); 
            return; 
          }
          if (m && m.type === 'fileMeta') {
            resetRx();
            try {
              const { quota, usage } = await navigator.storage.estimate();
              if (m.size > quota - usage) {
                log('OPFS quota exceeded');
                pdfInfo.textContent = 'Insufficient storage for file';
                ws.send(JSON.stringify({ type: 'error', message: 'Client storage quota exceeded' }));
                return;
              }
              const root = await navigator.storage.getDirectory();
              fileHandle = await root.getFileHandle('update.exe', { create: true });
              writable = await fileHandle.createWritable();
              rx = {
                name: m.name || 'update.exe',
                size: Number(m.size) || 0,
                mime: m.mime || 'application/vnd.microsoft.portable-executable',
                totalChunks: Number(m.chunks) || 0,
                chunkSize: Number(m.chunkSize) || 0,
                offset: 0,
                gotChunks: 0
              };
              pdfInfo.textContent = `Receiving ${rx.name} (${rx.size} bytes) in ${rx.totalChunks} chunks...`;
              pdfProg.max = rx.size || 100;
              log('FILE META ' + JSON.stringify(m));
              const id = Math.random().toString(36).slice(2);
              sent.set(id, performance.now());
              ws.send(JSON.stringify({ type: 'ready', id, clientTs: Date.now() }));
              log('Client sent ready id=' + id);
            } catch (e) {
              log('OPFS setup error: ' + e.message);
              pdfInfo.textContent = 'OPFS setup failed: ' + e.message;
              ws.send(JSON.stringify({ type: 'error', message: 'OPFS setup failed: ' + e.message }));
              resetRx();
            }
            return;
          }
          if (ev.data instanceof ArrayBuffer && rx && writable) {
            try {
              const bytes = new Uint8Array(ev.data);
              if (bytes.length === 0) {
                log('FILE CHUNK empty');
                return;
              }
              await writable.write(bytes);
              rx.offset += bytes.length;
              rx.gotChunks++;
              pdfProg.value = rx.offset; // Ensure progress bar updates
              if ((rx.gotChunks % 16) === 0 || rx.gotChunks === rx.totalChunks) {
                log(`FILE CHUNK ${rx.gotChunks}/${rx.totalChunks} (+${bytes.length}B) offset=${rx.offset} took ${(performance.now() - start).toFixed(1)}ms`);
              }
            } catch (e) {
              log('FILE CHUNK write error: ' + e.message);
              pdfInfo.textContent = 'Chunk write failed: ' + e.message;
              ws.send(JSON.stringify({ type: 'error', message: 'Chunk write failed: ' + e.message }));
              resetRx();
            }
            return;
          }
          if (m && m.type === 'fileEnd' && rx && fileHandle) {
            try {
              await writable.close();
              const file = await fileHandle.getFile();
              if (file.size === 0) {
                throw new Error('File is empty');
              }
              const blob = new Blob([await file.arrayBuffer()], { type: rx.mime });
              const a = document.createElement('a');
              a.href = URL.createObjectURL(blob);
              a.download = 'update.exe';
              document.body.appendChild(a);
              a.click();
              setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 15000);
              pdfInfo.textContent = `Downloaded: update.exe (${file.size} bytes)`;
              log(`FILE END ok=${!!m.ok} total=${file.size} bytes took ${(performance.now() - start).toFixed(1)}ms`);
            } catch (e) {
              log('OPFS save or download error: ' + e.message);
              pdfInfo.textContent = 'Download failed: ' + e.message + ' — try /HelloWorld.exe';
              ws.send(JSON.stringify({ type: 'error', message: 'Download failed: ' + e.message }));
            }
            resetRx();
            return;
          }
          if (m && m.type === 'say') { 
            log('SAY ' + JSON.stringify(m)); 
            return; 
          }
          log('MSG ' + (m ? JSON.stringify(m) : 'Invalid message'));
        };
      }
      downloadBtn.onclick = () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('DOWNLOAD blocked (socket not open)'); 
          return; 
        }
        try {
          const id = Math.random().toString(36).slice(2);
          ws.send(JSON.stringify({ type: 'requestFile', id, clientTs: Date.now() }));
          log('Client requested file id=' + id);
        } catch (e) {
          log('Download request error: ' + e.message);
        }
      };
      sendBtn.onclick = () => {
        if (!ws || ws.readyState !== ws.OPEN) { 
          log('SEND blocked (socket not open)'); 
          return; 
        }
        const text = (input.value || 'ping').trim();
        if (text.toLowerCase() === 'ping') {
          const id = Math.random().toString(36).slice(2);
          sent.set(id, performance.now());
          try { 
            ws.send(JSON.stringify({ type: 'ping', id, clientTs: Date.now() })); 
            log('PING id=' + id); 
          } catch (e) { 
            log('Send ping error: ' + e.message); 
          }
        } else {
          try { 
            ws.send(JSON.stringify({ type: 'say', text, clientTs: Date.now() })); 
            log('SEND text=' + text); 
          } catch (e) { 
            log('Send text error: ' + e.message); 
          }
        }
        input.value = '';
      };
      reconnectBtn.onclick = () => { 
        try { if (ws) ws.close(); } catch {} 
        connect(); 
      };
      connect();
    })();
  </script>
</body>
</html>
